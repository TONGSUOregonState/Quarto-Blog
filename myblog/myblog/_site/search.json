[
  {
    "objectID": "Linkedlist.html",
    "href": "Linkedlist.html",
    "title": "Linked List Demo",
    "section": "",
    "text": "```{.c} #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;\n// … 这里粘贴完整的 Linkedlist.c 代码 … #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;\ntypedef struct Node { char name[32]; struct Node *next; } Node;\n/* 在链表尾部插入 name，返回“新的尾结点” / Node push_back(Node last, const char name) { Node p = (Node)malloc(sizeof(Node)); if (!p) { perror(“malloc”); exit(1); }\nstrncpy(p-&gt;name, name, sizeof(p-&gt;name)-1);\np-&gt;name[sizeof(p-&gt;name)-1] = '\\0';\np-&gt;next = NULL;\n\nif (last) {               // 不是第一个节点：把它接在尾巴后\n    last-&gt;next = p;\n}\nreturn p;                 // 返回新的“尾结点”\n}\n/* 打印链表 / void print_list(Node head) { for (Node *cur = head; cur; cur = cur-&gt;next) { printf(“%s%s”, cur-&gt;name, cur-&gt;next ? ” -&gt; ” : ” -&gt; null“); } }\n/* 统计节点数 / int count(Node h) { int numberofnodes = 0; for (Node *p = h; p != NULL; p = p-&gt;next) { numberofnodes++; } return numberofnodes; }\nint main(void) { Node head = NULL; Node tail = NULL;\n// 构造图里的初始链表：Jacob -&gt; Joseph -&gt; Mary\ntail = push_back(NULL, \"Jacob\");  // 第一个节点\nhead = tail;                      // 记录头指针\ntail = push_back(tail, \"Joseph\"); // 接在尾部\ntail = push_back(tail, \"Mary\");\n\nprint_list(head);\nprintf(\"This linked list has %d nodes.\\n\\n\", count(head));\n\n// 在末尾插入 Ann（对应 Fig. 3.6 第二行）\ntail = push_back(tail, \"Ann\");\n\nprint_list(head);\nprintf(\"This linked list has %d nodes.\\n\", count(head));\n\nreturn 0;\n}"
  },
  {
    "objectID": "Linkedlist.html#原始-c-程序",
    "href": "Linkedlist.html#原始-c-程序",
    "title": "Linked List Demo",
    "section": "",
    "text": "```{.c} #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;\n// … 这里粘贴完整的 Linkedlist.c 代码 … #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;\ntypedef struct Node { char name[32]; struct Node *next; } Node;\n/* 在链表尾部插入 name，返回“新的尾结点” / Node push_back(Node last, const char name) { Node p = (Node)malloc(sizeof(Node)); if (!p) { perror(“malloc”); exit(1); }\nstrncpy(p-&gt;name, name, sizeof(p-&gt;name)-1);\np-&gt;name[sizeof(p-&gt;name)-1] = '\\0';\np-&gt;next = NULL;\n\nif (last) {               // 不是第一个节点：把它接在尾巴后\n    last-&gt;next = p;\n}\nreturn p;                 // 返回新的“尾结点”\n}\n/* 打印链表 / void print_list(Node head) { for (Node *cur = head; cur; cur = cur-&gt;next) { printf(“%s%s”, cur-&gt;name, cur-&gt;next ? ” -&gt; ” : ” -&gt; null“); } }\n/* 统计节点数 / int count(Node h) { int numberofnodes = 0; for (Node *p = h; p != NULL; p = p-&gt;next) { numberofnodes++; } return numberofnodes; }\nint main(void) { Node head = NULL; Node tail = NULL;\n// 构造图里的初始链表：Jacob -&gt; Joseph -&gt; Mary\ntail = push_back(NULL, \"Jacob\");  // 第一个节点\nhead = tail;                      // 记录头指针\ntail = push_back(tail, \"Joseph\"); // 接在尾部\ntail = push_back(tail, \"Mary\");\n\nprint_list(head);\nprintf(\"This linked list has %d nodes.\\n\\n\", count(head));\n\n// 在末尾插入 Ann（对应 Fig. 3.6 第二行）\ntail = push_back(tail, \"Ann\");\n\nprint_list(head);\nprintf(\"This linked list has %d nodes.\\n\", count(head));\n\nreturn 0;\n}"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]