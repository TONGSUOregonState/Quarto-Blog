[
  {
    "objectID": "updates.html",
    "href": "updates.html",
    "title": "æ›´æ–°æ—¥å¿—",
    "section": "",
    "text": "æœ€åç”Ÿæˆäºï¼š2025-11-11 03:10"
  },
  {
    "objectID": "updates.html#æœ€è¿‘æ›´æ–°å‰-20-æ¡",
    "href": "updates.html#æœ€è¿‘æ›´æ–°å‰-20-æ¡",
    "title": "æ›´æ–°æ—¥å¿—",
    "section": "æœ€è¿‘æ›´æ–°ï¼ˆå‰ 20 æ¡ï¼‰",
    "text": "æœ€è¿‘æ›´æ–°ï¼ˆå‰ 20 æ¡ï¼‰\n\nindex â€” 2025-11-11 02:44\nindex â€” 2025-11-11 02:44\nindex â€” 2025-11-11 02:44\nindex â€” 2025-11-11 02:44\nsetCapacityFucntionIllustration â€” 2025-11-02 14:34\n53Stracatdemo â€” 2025-11-02 14:30\nindex â€” 2025-11-02 14:27\nindex â€” 2025-11-02 14:26\nindex â€” 2025-11-02 14:24\nCPointer â€” 2025-11-02 03:15\nindex â€” 2025-11-02 03:09\nOctober5thPractice â€” 2025-11-02 03:08\nLinkedlist â€” 2025-11-02 03:07\nHackerRank â€” 2025-11-02 03:06\nDynamicArray1 â€” 2025-11-02 03:05\nExample1 â€” 2025-10-12 19:25\ncode editor â€” 2025-10-11 01:05\npushbackcomplete â€” 2025-09-27 18:58\npushbackattempt â€” 2025-09-27 18:55\npushbackattempt2 â€” 2025-09-26 19:00"
  },
  {
    "objectID": "myblog/about.html",
    "href": "myblog/about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "Example1.html",
    "href": "Example1.html",
    "title": "Quarto Basics",
    "section": "",
    "text": "For a demonstration of a line plot on a polar axis, see FigureÂ 1.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.arange(0, 2, 0.01)\ntheta = 2 * np.pi * r\nfig, ax = plt.subplots(\n  subplot_kw = {'projection': 'polar'} \n)\nax.plot(theta, r)\nax.set_rticks([0.5, 1, 1.5, 2])\nax.grid(True)\nplt.show()\n\n\n\n\n\n\n\n\nFigureÂ 1: A line plot on a polar axis"
  },
  {
    "objectID": "data-structures/python/index.html",
    "href": "data-structures/python/index.html",
    "title": "Data Structures with Python",
    "section": "",
    "text": "æ¬¢è¿æ¥åˆ° Python æ•°æ®ç»“æ„ä¸“åŒºï¼è¿™é‡Œåˆ†äº«å¸¸ç”¨å®¹å™¨å®ç°ä¸ç®—æ³•å®è·µã€‚\n\n\nâ† è¿”å› Data Structures é¦–é¡µ"
  },
  {
    "objectID": "data-structures/python/index.html#æ–‡ç« ",
    "href": "data-structures/python/index.html#æ–‡ç« ",
    "title": "Data Structures with Python",
    "section": "",
    "text": "â† è¿”å› Data Structures é¦–é¡µ"
  },
  {
    "objectID": "data-structures/index.html",
    "href": "data-structures/index.html",
    "title": "Data Structures",
    "section": "",
    "text": "Data Structures with C\n\n\n\n\n\n\n\n\n\n\n\n\n\nData Structures with C++\n\n\n\n\n\n\n\n\n\n\n\n\n\nData Structures with Java\n\n\n\n\n\n\n\n\n\n\n\n\n\nData Structures with Python\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "data-structures/C/index.html",
    "href": "data-structures/C/index.html",
    "title": "Data Structures with C",
    "section": "",
    "text": "æ¬¢è¿æ¥åˆ° C æ•°æ®ç»“æ„ä¸“åŒºï¼è¿™é‡Œè®°å½•æŒ‡é’ˆã€å†…å­˜ç®¡ç†ä¸å¸¸ç”¨æ•°æ®ç»“æ„å®ç°ã€‚\n\n\nâ† è¿”å› Data Structures é¦–é¡µ"
  },
  {
    "objectID": "data-structures/C/index.html#æ–‡ç« ",
    "href": "data-structures/C/index.html#æ–‡ç« ",
    "title": "Data Structures with C",
    "section": "",
    "text": "â† è¿”å› Data Structures é¦–é¡µ"
  },
  {
    "objectID": "c-programming/pushbackcomplete.html",
    "href": "c-programming/pushbackcomplete.html",
    "title": "pushback complete program integer version",
    "section": "",
    "text": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\ntypedef struct Node {\n    int data;\n    //pointer to the next Node\n    struct Node *next;\n}Node;\n//give struct node another name Node\n\nint main(void);\n//we need a main function to test\nvoid print_list(Node *head);\n//we need a function print list to print the entrie nodes the function doest return anything thus it is void type\n// we need the head pointer of the entire Node as a reference to print the entire node list\nNode* push_back(Node *last, int value);\n//we need a push function to push every data to the last node of the entire node list\n//the type is Node* beacuse we want it to return the pointer of the new node\n\nNode* push_back(Node *last, int value){\n    if(last == NULL){\n        last = (Node *)malloc(sizeof(Node));\n        //if there is no node in the entire list, we just assign last as a node, (Node * implies that we want to the malloc give us type Node*, but not void*)\n        last-&gt;data = value;\n        last-&gt;next = NULL;\n        //since it is the last node, the next pointer should point to NULL\n        //we then return the address of the last node\n        return last;\n    }\n    else{\n        Node *newNode = (Node *)malloc(sizeof(Node));\n        newNode-&gt;data = value;\n        last-&gt;next = newNode;\n        newNode-&gt;next = NULL;\n       \n        return newNode;\n    }\n}\nvoid print_list(Node *head){\n    for(Node *cur = head;cur;cur = cur-&gt;next){\n        printf(\"%d\",cur-&gt;data);\n        printf(\"\\n\");\n       }\n     printf(\"\\n\");\n}\nint main(void){\n        Node *head = NULL; Node *tail = NULL;\n        tail = push_back(NULL,11111);\n        head = tail;\n        \n        tail = push_back(tail, 11112);\n        tail = push_back(tail, 11113);\n        \n        print_list(head);\n \n        \n        return 0;\n}"
  },
  {
    "objectID": "c-programming/pushbackcomplete.html#execution-result",
    "href": "c-programming/pushbackcomplete.html#execution-result",
    "title": "pushback complete program integer version",
    "section": "Execution result",
    "text": "Execution result\n111111 11112 11113"
  },
  {
    "objectID": "c-programming/pushbackattempt.html",
    "href": "c-programming/pushbackattempt.html",
    "title": "Linkedlist Attempt,recitating push_back function , print function,",
    "section": "",
    "text": "Show the code\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct Node{\n    int info;\n    struct Node *next;\n}Node;\n\nNode* push_back(Node *last, int info);\nvoid print_list(Node *head);\n\n\n\n\nint main(void){\n    Node *head = NULL, *tail = NULL;\n    tail = push_back(NULL,11); \n    head = tail;\n    print_list(head); \n    return 0;\n}\n\nNode* push_back(Node *last, int info){\n    if(last == NULL){\n        Node *newNode = (Node *)malloc(sizeof(Node));\n        //loaded info value\n        newNode-&gt;info = info;\n        //setup the next pointer to NULL\n        newNode-&gt;next = NULL;\n           //return the back of the list\n        return newNode;\n    }\n}\n//print function\nvoid print_list(Node *head){\n    Node *cur = head;\n    while (cur!= NULL){\n        printf(\"%d -&gt;\", cur-&gt;info);\n        cur = cur-&gt;next;\n    }\n    printf(\"NULL\\n\");\n}"
  },
  {
    "objectID": "c-programming/pushbackattempt.html#attempt-1",
    "href": "c-programming/pushbackattempt.html#attempt-1",
    "title": "Linkedlist Attempt,recitating push_back function , print function,",
    "section": "",
    "text": "Show the code\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct Node{\n    int info;\n    struct Node *next;\n}Node;\n\nNode* push_back(Node *last, int info);\nvoid print_list(Node *head);\n\n\n\n\nint main(void){\n    Node *head = NULL, *tail = NULL;\n    tail = push_back(NULL,11); \n    head = tail;\n    print_list(head); \n    return 0;\n}\n\nNode* push_back(Node *last, int info){\n    if(last == NULL){\n        Node *newNode = (Node *)malloc(sizeof(Node));\n        //loaded info value\n        newNode-&gt;info = info;\n        //setup the next pointer to NULL\n        newNode-&gt;next = NULL;\n           //return the back of the list\n        return newNode;\n    }\n}\n//print function\nvoid print_list(Node *head){\n    Node *cur = head;\n    while (cur!= NULL){\n        printf(\"%d -&gt;\", cur-&gt;info);\n        cur = cur-&gt;next;\n    }\n    printf(\"NULL\\n\");\n}"
  },
  {
    "objectID": "c-programming/pushbackattempt.html#execution-result",
    "href": "c-programming/pushbackattempt.html#execution-result",
    "title": "Linkedlist Attempt,recitating push_back function , print function,",
    "section": "execution result",
    "text": "execution result\n11 -&gt;NULL\n=== Code Execution Successful ===\n\n\nShow the code\n\n\n&lt;&gt;\n##Execution result"
  },
  {
    "objectID": "c-programming/Linkedlist.html",
    "href": "c-programming/Linkedlist.html",
    "title": "Linked list Program",
    "section": "",
    "text": "Show the code\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct Node {\n    char name[32];\n    struct Node *next;\n} Node;\n\n/* åœ¨é“¾è¡¨å°¾éƒ¨æ’å…¥ nameï¼Œè¿”å›\"æ–°çš„å°¾ç»“ç‚¹\" */\nNode* push_back(Node *last, const char *name) {\n    Node *p = (Node*)malloc(sizeof(Node));\n    if (!p) { perror(\"malloc\"); exit(1); }\n\n    strncpy(p-&gt;name, name, sizeof(p-&gt;name)-1);\n    p-&gt;name[sizeof(p-&gt;name)-1] = '\\0';\n    p-&gt;next = NULL;\n\n    if (last) { last-&gt;next = p; }\n    return p;\n}\n\nvoid print_list(Node *head) {\n    for (Node *cur = head; cur; cur = cur-&gt;next) {\n        printf(\"%s%s\", cur-&gt;name, cur-&gt;next ? \" -&gt; \" : \" -&gt; null\\n\");\n    }\n}\n\nint count(Node *h) {\n    int n = 0; for (Node *p = h; p; p = p-&gt;next) n++; return n;\n}\n\nint main(void) {\n    Node *head = NULL, *tail = NULL;\n    tail = push_back(NULL, \"Jacob\"); head = tail;\n    tail = push_back(tail, \"Joseph\");\n    tail = push_back(tail, \"Mary\");\n    print_list(head);\n    printf(\"This linked list has %d nodes.\\n\\n\", count(head));\n    tail = push_back(tail, \"Ann\");\n    print_list(head);\n    printf(\"This linked list has %d nodes.\\n\", count(head));\n    return 0;\n}"
  },
  {
    "objectID": "c-programming/Linkedlist.html#åŸå§‹-c-ç¨‹åº",
    "href": "c-programming/Linkedlist.html#åŸå§‹-c-ç¨‹åº",
    "title": "Linked list Program",
    "section": "",
    "text": "Show the code\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct Node {\n    char name[32];\n    struct Node *next;\n} Node;\n\n/* åœ¨é“¾è¡¨å°¾éƒ¨æ’å…¥ nameï¼Œè¿”å›\"æ–°çš„å°¾ç»“ç‚¹\" */\nNode* push_back(Node *last, const char *name) {\n    Node *p = (Node*)malloc(sizeof(Node));\n    if (!p) { perror(\"malloc\"); exit(1); }\n\n    strncpy(p-&gt;name, name, sizeof(p-&gt;name)-1);\n    p-&gt;name[sizeof(p-&gt;name)-1] = '\\0';\n    p-&gt;next = NULL;\n\n    if (last) { last-&gt;next = p; }\n    return p;\n}\n\nvoid print_list(Node *head) {\n    for (Node *cur = head; cur; cur = cur-&gt;next) {\n        printf(\"%s%s\", cur-&gt;name, cur-&gt;next ? \" -&gt; \" : \" -&gt; null\\n\");\n    }\n}\n\nint count(Node *h) {\n    int n = 0; for (Node *p = h; p; p = p-&gt;next) n++; return n;\n}\n\nint main(void) {\n    Node *head = NULL, *tail = NULL;\n    tail = push_back(NULL, \"Jacob\"); head = tail;\n    tail = push_back(tail, \"Joseph\");\n    tail = push_back(tail, \"Mary\");\n    print_list(head);\n    printf(\"This linked list has %d nodes.\\n\\n\", count(head));\n    tail = push_back(tail, \"Ann\");\n    print_list(head);\n    printf(\"This linked list has %d nodes.\\n\", count(head));\n    return 0;\n}"
  },
  {
    "objectID": "c-programming/Linkedlist.html#ç¨‹åºè¯´æ˜",
    "href": "c-programming/Linkedlist.html#ç¨‹åºè¯´æ˜",
    "title": "Linked list Program",
    "section": "ç¨‹åºè¯´æ˜",
    "text": "ç¨‹åºè¯´æ˜\nè¿™æ˜¯ä¸€ä¸ªç®€å•çš„å•å‘é“¾è¡¨å®ç°ï¼ŒåŒ…å«ä»¥ä¸‹åŠŸèƒ½ï¼š\n\nç»“æ„å®šä¹‰ï¼šNode ç»“æ„åŒ…å«å§“åå­—ç¬¦ä¸²å’ŒæŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ\næ’å…¥åŠŸèƒ½ï¼špush_back() å‡½æ•°åœ¨é“¾è¡¨å°¾éƒ¨æ·»åŠ æ–°èŠ‚ç‚¹\næ‰“å°åŠŸèƒ½ï¼šprint_list() å‡½æ•°éå†å¹¶æ‰“å°æ•´ä¸ªé“¾è¡¨\nè®¡æ•°åŠŸèƒ½ï¼šcount() å‡½æ•°è¿”å›é“¾è¡¨ä¸­èŠ‚ç‚¹çš„æ•°é‡"
  },
  {
    "objectID": "c-programming/Linkedlist.html#é¢„æœŸè¾“å‡º",
    "href": "c-programming/Linkedlist.html#é¢„æœŸè¾“å‡º",
    "title": "Linked list Program",
    "section": "é¢„æœŸè¾“å‡º",
    "text": "é¢„æœŸè¾“å‡º\nJacob -&gt; Joseph -&gt; Mary -&gt; null\nThis linked list has 3 nodes.\n\nJacob -&gt; Joseph -&gt; Mary -&gt; Ann -&gt; null\nThis linked list has 4 nodes.\n---\ntitle: \"é€è¡Œè§£æï¼šmain ç¨‹åº\"\nformat: html\n---\n\n## ç¨‹åºä»£ç ä¸é€è¡Œè§£é‡Š\n\n```c\nint main(void) {\nğŸ‘‰ ç¨‹åºå…¥å£å‡½æ•°ï¼Œè¿”å›ç±»å‹æ˜¯ intï¼Œå‚æ•°ä¸ºç©ºï¼ˆvoid è¡¨ç¤º main ä¸æ¥æ”¶å‘½ä»¤è¡Œå‚æ•°ï¼‰ã€‚\n\n    Node *head = NULL, *tail = NULL;\nğŸ‘‰ å®šä¹‰ä¸¤ä¸ªæŒ‡å‘ Node çš„æŒ‡é’ˆå˜é‡ï¼š\n\nheadï¼šæŒ‡å‘é“¾è¡¨çš„å¤´ç»“ç‚¹ï¼ˆç¬¬ä¸€ä¸ªç»“ç‚¹ï¼‰ã€‚\ntailï¼šæŒ‡å‘é“¾è¡¨çš„å°¾ç»“ç‚¹ï¼ˆæœ€åä¸€ä¸ªç»“ç‚¹ï¼‰ã€‚ ä¸€å¼€å§‹å®ƒä»¬éƒ½è®¾ä¸º NULLï¼Œè¡¨ç¤ºé“¾è¡¨è¿˜æ²¡æœ‰ä»»ä½•èŠ‚ç‚¹ã€‚\n\n\n    tail = push_back(NULL, \"Jacob\"); head = tail;\nğŸ‘‰ è°ƒç”¨ push_back åœ¨ä¸€ä¸ªç©ºé“¾è¡¨ä¸­æ’å…¥ \"Jacob\" èŠ‚ç‚¹ã€‚\n\nè¿”å›çš„æ–°èŠ‚ç‚¹åœ°å€èµ‹ç»™ tailï¼ˆå³å°¾ç»“ç‚¹ï¼‰ã€‚\nåŒæ—¶å› ä¸ºè¿™æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ‰€ä»¥ head = tailï¼Œé“¾è¡¨çš„å¤´å’Œå°¾éƒ½æŒ‡å‘è¿™ä¸ªæ–°èŠ‚ç‚¹ã€‚\n\n\n    tail = push_back(tail, \"Joseph\");\nğŸ‘‰ åœ¨å½“å‰å°¾ç»“ç‚¹ \"Jacob\" åé¢æ’å…¥ \"Joseph\" èŠ‚ç‚¹ã€‚ push_back ä¼šè¿”å›æ–°çš„å°¾ç»“ç‚¹ \"Joseph\"ï¼Œèµ‹å€¼ç»™ tailã€‚ ç°åœ¨é“¾è¡¨æ˜¯ï¼š\nJacob -&gt; Joseph\n\n    tail = push_back(tail, \"Mary\");\nğŸ‘‰ åœ¨ \"Joseph\" åé¢æ’å…¥ \"Mary\" èŠ‚ç‚¹ã€‚ è¿”å›çš„æ–°å°¾ç»“ç‚¹ \"Mary\" å­˜å…¥ tailã€‚ é“¾è¡¨å˜ä¸ºï¼š\nJacob -&gt; Joseph -&gt; Mary\n\n    print_list(head);\nğŸ‘‰ ä» head å¼€å§‹éå†é“¾è¡¨ï¼ŒæŠŠé“¾è¡¨æ‰€æœ‰èŠ‚ç‚¹çš„ name æ‰“å°å‡ºæ¥ã€‚ è¾“å‡ºç±»ä¼¼ï¼š\nJacob -&gt; Joseph -&gt; Mary\n\n    printf(\"This linked list has %d nodes.\\n\\n\", count(head));\nğŸ‘‰ è°ƒç”¨ count(head) æ¥ç»Ÿè®¡é“¾è¡¨ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°ï¼Œç„¶åè¾“å‡ºç»“æœã€‚ è¿™æ—¶é“¾è¡¨æœ‰ 3 ä¸ªèŠ‚ç‚¹ï¼Œè¾“å‡ºï¼š\nThis linked list has 3 nodes.\n\n    tail = push_back(tail, \"Ann\");\nğŸ‘‰ åœ¨ \"Mary\" åé¢æ’å…¥ \"Ann\" èŠ‚ç‚¹ï¼Œtail æ›´æ–°ä¸º \"Ann\"ã€‚ é“¾è¡¨å˜ä¸ºï¼š\nJacob -&gt; Joseph -&gt; Mary -&gt; Ann\n\n    print_list(head);\nğŸ‘‰ å†æ¬¡æ‰“å°æ•´ä¸ªé“¾è¡¨ï¼š\nJacob -&gt; Joseph -&gt; Mary -&gt; Ann\n\n    printf(\"This linked list has %d nodes.\\n\", count(head));\nğŸ‘‰ å†æ¬¡ç»Ÿè®¡å¹¶è¾“å‡ºèŠ‚ç‚¹æ•°é‡ï¼Œè¿™æ¬¡æ˜¯ 4ï¼š\nThis linked list has 4 nodes.\n\n    return 0;\n}\nğŸ‘‰ è¿”å› 0ï¼Œè¡¨ç¤ºç¨‹åºæ­£å¸¸ç»“æŸã€‚\n\n---\n\nè¦ä¸è¦æˆ‘å¸®ä½ åŠ ä¸€ä¸ª **ç¤ºæ„å›¾**ï¼ˆheadã€tail æ¯ä¸€æ­¥æŒ‡å‘æƒ…å†µï¼‰æ”¾åœ¨ qmd é‡Œï¼Ÿè¿™æ ·æ¸²æŸ“åä¸ä»…æœ‰æ–‡å­—è§£é‡Šï¼Œè¿˜èƒ½ç›´è§‚çœ‹é“¾è¡¨ç»“æ„ã€‚"
  },
  {
    "objectID": "c-programming/HackerRank.html",
    "href": "c-programming/HackerRank.html",
    "title": "Solutions 5.3 Optimized Strcat.C",
    "section": "",
    "text": "#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\n\nclass Triangle{\n    public:\n        void triangle(){\n            cout&lt;&lt;\"I am a triangle\\n\";\n        }\n};\n\nclass Isosceles : public Triangle{\n    public:\n        void isosceles(){\n            cout&lt;&lt;\"I am an isosceles triangle\\n\";\n        }\n        //Write your code here.\n};\n\nint main(){\n    Isosceles isc;\n    isc.isosceles();\n    isc.description();\n    isc.triangle();\n    return 0;\n}"
  },
  {
    "objectID": "c-programming/HackerRank.html#hackerrank-problem",
    "href": "c-programming/HackerRank.html#hackerrank-problem",
    "title": "Solutions 5.3 Optimized Strcat.C",
    "section": "",
    "text": "#include &lt;cmath&gt;\n#include &lt;cstdio&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\nusing namespace std;\n\n\nclass Triangle{\n    public:\n        void triangle(){\n            cout&lt;&lt;\"I am a triangle\\n\";\n        }\n};\n\nclass Isosceles : public Triangle{\n    public:\n        void isosceles(){\n            cout&lt;&lt;\"I am an isosceles triangle\\n\";\n        }\n        //Write your code here.\n};\n\nint main(){\n    Isosceles isc;\n    isc.isosceles();\n    isc.description();\n    isc.triangle();\n    return 0;\n}"
  },
  {
    "objectID": "c-programming/CPointer.html",
    "href": "c-programming/CPointer.html",
    "title": "Pointer",
    "section": "",
    "text": "Person *p;\nè¿™ä¸€å¥æ˜¯å®šä¹‰å˜é‡ï¼š\næ‰€ä»¥ï¼š ğŸ‘‰ p æœ¬èº«æ˜¯ä¸ªæŒ‡é’ˆå˜é‡ï¼Œå®ƒé‡Œé¢å­˜çš„æ˜¯ä¸€ä¸ªåœ°å€ã€‚ ğŸ‘‰ è¿™ä¸ªåœ°å€å¿…é¡»æ˜¯æŸä¸ª Person ç±»å‹å¯¹è±¡çš„åœ°å€ã€‚"
  },
  {
    "objectID": "c-programming/CPointer.html#tom",
    "href": "c-programming/CPointer.html#tom",
    "title": "Pointer",
    "section": "2. &tom",
    "text": "2. &tom\nPerson tom;\n&tom;\n\ntom æ˜¯ä¸€ä¸ª Person ç±»å‹çš„ç»“æ„ä½“å˜é‡ã€‚\n&tom è¡¨ç¤ºâ€œå– tom çš„åœ°å€â€ã€‚\n&tom çš„ç±»å‹æ˜¯ Person*ã€‚\n\nè¿™ä¸ p çš„ç±»å‹åˆšå¥½åŒ¹é…ã€‚"
  },
  {
    "objectID": "c-programming/CPointer.html#p-tom",
    "href": "c-programming/CPointer.html#p-tom",
    "title": "Pointer",
    "section": "3. p = &tom",
    "text": "3. p = &tom\np = &tom;\næŠŠ tom çš„åœ°å€å­˜è¿› pã€‚ç»“æœæ˜¯ï¼šp æŒ‡å‘ tomã€‚\nå†…å­˜å¯ä»¥æƒ³è±¡æˆè¿™æ ·ï¼š\ntom (ç±»å‹ Person)          p (ç±»å‹ Person*)\n+------------------+       +----------------+\n| name[32]         |       | 0x1000 (åœ°å€) |\n| age              |       +----------------+\n+------------------+\n      ^\n      |\n      +---- p é‡Œé¢å­˜çš„å°±æ˜¯ tom çš„åœ°å€ 0x1000"
  },
  {
    "objectID": "c-programming/CPointer.html#p-çš„æ„æ€",
    "href": "c-programming/CPointer.html#p-çš„æ„æ€",
    "title": "Pointer",
    "section": "4. *p çš„æ„æ€",
    "text": "4. *p çš„æ„æ€\n\np æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œå­˜äº†åœ°å€ã€‚\n*p è¡¨ç¤ºâ€œè§£å¼•ç”¨â€è¿™ä¸ªæŒ‡é’ˆï¼Œæ‰¾åˆ°å®ƒæŒ‡å‘çš„å¯¹è±¡â€ã€‚\næ‰€ä»¥ *p çš„ç±»å‹æ˜¯ Personï¼Œç­‰ä»·äºâ€œtom æœ¬èº«â€ã€‚\n\nç¤ºä¾‹ï¼š\n(*p).age = 20;   // ç›¸å½“äº tom.age = 20;"
  },
  {
    "objectID": "c-programming/CPointer.html#å’Œ---çš„å…³ç³»",
    "href": "c-programming/CPointer.html#å’Œ---çš„å…³ç³»",
    "title": "Pointer",
    "section": "5. å’Œ -> çš„å…³ç³»",
    "text": "5. å’Œ -&gt; çš„å…³ç³»\nå› ä¸º (*p).age å¤ªå•°å—¦ï¼ŒC æä¾›ç®€å†™ï¼š\np-&gt;age = 20;   // ç­‰ä»·äº (*p).age"
  },
  {
    "objectID": "c-programming/CPointer.html#æ€»ç»“ä¸€å¥",
    "href": "c-programming/CPointer.html#æ€»ç»“ä¸€å¥",
    "title": "Pointer",
    "section": "âœ… æ€»ç»“ä¸€å¥",
    "text": "âœ… æ€»ç»“ä¸€å¥\n\np æ˜¯ä¸ªæŒ‡é’ˆå˜é‡ï¼Œé‡Œé¢å­˜çš„æ˜¯ tom çš„åœ°å€ã€‚\n*p ä¸æ˜¯â€œæŒ‡é’ˆâ€ï¼Œè€Œæ˜¯â€œæŒ‡é’ˆæ‰€æŒ‡çš„å¯¹è±¡â€ï¼ˆå³ tomï¼‰ã€‚\n&tom æ˜¯å– tom çš„åœ°å€ï¼Œæ­£å¥½èƒ½èµ‹å€¼ç»™ pã€‚\n\n```"
  },
  {
    "objectID": "c-programming/53Stracatdemo.html",
    "href": "c-programming/53Stracatdemo.html",
    "title": "Solutions 5.3 Optimized Strcat.C",
    "section": "",
    "text": "Show the code\n\nvoid strcat(char s[], char t[]) {\n    int i = 0, j = 0;\n    while (s[i] != '\\0')  // æ‰¾åˆ° s çš„ç»“å°¾\n        i++;\n    while ((s[i++] = t[j++]) != '\\0') // å¤åˆ¶ t\n        ;\n}"
  },
  {
    "objectID": "c-programming/53Stracatdemo.html#original-chapter-2-code",
    "href": "c-programming/53Stracatdemo.html#original-chapter-2-code",
    "title": "Solutions 5.3 Optimized Strcat.C",
    "section": "",
    "text": "Show the code\n\nvoid strcat(char s[], char t[]) {\n    int i = 0, j = 0;\n    while (s[i] != '\\0')  // æ‰¾åˆ° s çš„ç»“å°¾\n        i++;\n    while ((s[i++] = t[j++]) != '\\0') // å¤åˆ¶ t\n        ;\n}"
  },
  {
    "objectID": "c-programming/53Stracatdemo.html#solution-of-exercise-5.2",
    "href": "c-programming/53Stracatdemo.html#solution-of-exercise-5.2",
    "title": "Solutions 5.3 Optimized Strcat.C",
    "section": "Solution of Exercise 5.2",
    "text": "Solution of Exercise 5.2\n\n\nShow the code\n\n#include &lt;stdio.h&gt;\n\nvoid strcat_ptr(char *s, char *t);\n\nint main(void)\n{\n  char s[100] = \"This is the first string\";\n  char t[] = \", this second string!\";\n\n  strcat_ptr(s, t);\n\n  puts(s);\n\n  return 0;\n}\n\n// Concatenate t to end of s; s must be big enough.\nvoid strcat_ptr(char *s, char *t)\n{\n  // Find the end of s\n  while (*s)\n      ++s;\n\n  // copy t to the end of s\n  while (*s++ = *t++)\n    ;\n}"
  },
  {
    "objectID": "c-programming/53Stracatdemo.html#æ•´ä½“ä»£ç ",
    "href": "c-programming/53Stracatdemo.html#æ•´ä½“ä»£ç ",
    "title": "Solutions 5.3 Optimized Strcat.C",
    "section": "æ•´ä½“ä»£ç ",
    "text": "æ•´ä½“ä»£ç \nvoid strcat(char s[], char t[]) {\n    int i = 0, j = 0;\n    while (s[i] != '\\0')  // æ‰¾åˆ° s çš„ç»“å°¾\n        i++;\n    while ((s[i++] = t[j++]) != '\\0') // å¤åˆ¶ t\n        ;\n}"
  },
  {
    "objectID": "c-programming/53Stracatdemo.html#void-strcatchar-s-char-t",
    "href": "c-programming/53Stracatdemo.html#void-strcatchar-s-char-t",
    "title": "Solutions 5.3 Optimized Strcat.C",
    "section": "1. void strcat(char s[], char t[]) {",
    "text": "1. void strcat(char s[], char t[]) {\n\nvoid â†’ å‡½æ•°è¿”å›ç±»å‹ï¼Œè¡¨ç¤ºè¿™ä¸ªå‡½æ•°æ²¡æœ‰è¿”å›å€¼ã€‚ ï¼ˆæ ‡å‡†åº“é‡Œçš„ strcat å®é™…ä¸Šè¿”å› char*ï¼Œè¿™é‡Œåªæ˜¯æ•™å­¦ç‰ˆæœ¬ã€‚ï¼‰\nstrcat â†’ å‡½æ•°åã€‚\nchar s[] â†’ å½¢å‚ï¼Œçœ‹èµ·æ¥æ˜¯â€œå­—ç¬¦æ•°ç»„â€ï¼Œä½†åœ¨å‡½æ•°å‚æ•°é‡Œ ä¼šé€€åŒ–æˆ char* æŒ‡é’ˆã€‚\n\næ‰€ä»¥ s å®é™…ä¸Šæ˜¯æŒ‡å‘å­—ç¬¦ä¸²é¦–å…ƒç´ çš„æŒ‡é’ˆã€‚\n\nchar t[] â†’ åŒç†ï¼ŒæŒ‡å‘å¦ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚\n\nğŸ‘‰ å‚æ•°è¯­ä¹‰ï¼šs = ç›®æ ‡å­—ç¬¦ä¸²ï¼›t = è¦è¿½åŠ çš„å­—ç¬¦ä¸²ã€‚"
  },
  {
    "objectID": "c-programming/53Stracatdemo.html#int-i-0-j-0",
    "href": "c-programming/53Stracatdemo.html#int-i-0-j-0",
    "title": "Solutions 5.3 Optimized Strcat.C",
    "section": "2. int i = 0, j = 0;",
    "text": "2. int i = 0, j = 0;\n\nå®šä¹‰ä¸¤ä¸ªæ•´å‹å˜é‡ iã€jã€‚\nå¹¶åˆå§‹åŒ–ä¸º 0ã€‚\nè¿™é‡Œ i ç”¨æ¥æ‰«æç›®æ ‡å­—ç¬¦ä¸² s çš„ä¸‹æ ‡ï¼›j ç”¨æ¥æ‰«ææºå­—ç¬¦ä¸² t çš„ä¸‹æ ‡ã€‚"
  },
  {
    "objectID": "c-programming/53Stracatdemo.html#while-si-0",
    "href": "c-programming/53Stracatdemo.html#while-si-0",
    "title": "Solutions 5.3 Optimized Strcat.C",
    "section": "3. while (s[i] != '\\0')",
    "text": "3. while (s[i] != '\\0')\n\nwhile (æ¡ä»¶) â†’ å½“æ¡ä»¶ä¸ºçœŸæ—¶ï¼Œå¾ªç¯æ‰§è¡Œã€‚\ns[i] â†’ è®¿é—®æ•°ç»„å…ƒç´ ï¼Œä¸‹æ ‡è¿ç®—ç¬¦ []ï¼Œç­‰ä»·äº *(s + i)ã€‚\n'\\0' â†’ C å­—ç¬¦ä¸²çš„ç»“æŸæ ‡å¿—ï¼ˆASCII å€¼ 0 çš„å­—ç¬¦ï¼‰ã€‚\næ¡ä»¶ï¼šs[i] != '\\0' â†’ è¡¨ç¤ºâ€œå½“å‰å­—ç¬¦ä¸æ˜¯å­—ç¬¦ä¸²ç»“å°¾â€ã€‚"
  },
  {
    "objectID": "c-programming/53Stracatdemo.html#i",
    "href": "c-programming/53Stracatdemo.html#i",
    "title": "Solutions 5.3 Optimized Strcat.C",
    "section": "4. i++;",
    "text": "4. i++;\n\ni++ â†’ åç¼€è‡ªå¢è¿ç®—ç¬¦ï¼Œç­‰ä»·äº i = i + 1ã€‚\nè¿™é‡Œç”¨æ¥å‘åç§»åŠ¨ä¸‹æ ‡ï¼Œç›´åˆ°é‡åˆ° '\\0'ã€‚\nä½œç”¨ï¼šæ‰¾åˆ° s çš„æœ«å°¾ã€‚"
  },
  {
    "objectID": "c-programming/53Stracatdemo.html#while-si-tj-0",
    "href": "c-programming/53Stracatdemo.html#while-si-tj-0",
    "title": "Solutions 5.3 Optimized Strcat.C",
    "section": "5. while ((s[i++] = t[j++]) != '\\0')",
    "text": "5. while ((s[i++] = t[j++]) != '\\0')\né€éƒ¨åˆ†æ‹†è§£ï¼š\n\n(s[i++] = t[j++]) â†’\n\nt[j++]ï¼šå…ˆå– t[j] çš„å€¼ï¼Œå†è®© j è‡ªå¢ã€‚\ns[i++] = ...ï¼šæŠŠè¿™ä¸ªå€¼èµ‹ç»™ s[i]ï¼Œå†è®© i è‡ªå¢ã€‚\nç»“æœæ˜¯æŠŠ t[j] çš„å­—ç¬¦å¤åˆ¶åˆ° s[i]ï¼Œç„¶åä¸¤ä¸ªä¸‹æ ‡éƒ½å¾€åç§»ä¸€ä½ã€‚\n\n!= '\\0' â†’ æ£€æŸ¥åˆšå¤åˆ¶çš„å­—ç¬¦æ˜¯ä¸æ˜¯ '\\0'ï¼ˆå­—ç¬¦ä¸²ç»“æŸæ ‡å¿—ï¼‰ã€‚\nå¦‚æœä¸æ˜¯ '\\0' â†’ å¾ªç¯ç»§ç»­ï¼Œå¤åˆ¶ä¸‹ä¸€ä¸ªå­—ç¬¦ã€‚\nå¦‚æœæ˜¯ '\\0' â†’ å¾ªç¯ç»“æŸï¼Œå®Œæˆè¿½åŠ ã€‚"
  },
  {
    "objectID": "c-programming/53Stracatdemo.html#section",
    "href": "c-programming/53Stracatdemo.html#section",
    "title": "Solutions 5.3 Optimized Strcat.C",
    "section": "6. ;",
    "text": "6. ;\n\nè¿™æ˜¯ä¸€ä¸ª ç©ºè¯­å¥ã€‚\nå› ä¸º while çš„å¾ªç¯ä½“å°±ä¸€è¡Œï¼Œè€Œä¸”é€»è¾‘å·²ç»åœ¨æ¡ä»¶é‡Œå®Œæˆï¼Œæ‰€ä»¥å†™ä¸€ä¸ªåˆ†å·è¡¨ç¤ºâ€œå¾ªç¯ä½“ä»€ä¹ˆéƒ½ä¸åšâ€ã€‚\nå®é™…å¾ªç¯ä½“çš„åŠ¨ä½œå°±æ˜¯æ¡ä»¶é‡Œçš„â€œèµ‹å€¼ + åˆ¤æ–­â€ã€‚"
  },
  {
    "objectID": "c-programming/53Stracatdemo.html#æ€»ç»“",
    "href": "c-programming/53Stracatdemo.html#æ€»ç»“",
    "title": "Solutions 5.3 Optimized Strcat.C",
    "section": "æ€»ç»“",
    "text": "æ€»ç»“\n\næ‰¾åˆ° s çš„æœ«å°¾ï¼š\nwhile (s[i] != '\\0') i++;\nä» t å¤åˆ¶åˆ° s çš„æœ«å°¾ï¼Œç›´åˆ° '\\0' ä¸ºæ­¢ï¼š\nwhile ((s[i++] = t[j++]) != '\\0');\n\næœ€ç»ˆæ•ˆæœï¼št çš„å†…å®¹è¢«æ¥åˆ° s åé¢ï¼Œå½¢æˆæ–°çš„å­—ç¬¦ä¸²ã€‚  â€”"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "c-programming/DynamicArray1.html",
    "href": "c-programming/DynamicArray1.html",
    "title": "Dynamic Array WS14",
    "section": "",
    "text": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;assert.h&gt;\n\n#ifndef TYPE\n#define TYPE double\n#endif\n\nstruct dynArr {\n    TYPE *data;     /* pointer to the data array */\n    int size;       /* number of elements in the array */\n    int capacity;   /* capacity of the data array */\n};\n\nvoid dynArrayInit(struct dynArr *v, int capacity) {\n    v-&gt;data = (TYPE *) malloc(sizeof(TYPE) * capacity);\n    assert(v-&gt;data != 0);\n    v-&gt;size = 0;\n    v-&gt;capacity = capacity;\n}\n\nvoid dynArrayFree(struct dynArr *v) {\n    if(v-&gt;data != 0) {\n        free(v-&gt;data);  /* free memory space */\n        v-&gt;data = 0;    /* make it point to NULL */\n    }\n    v-&gt;size = 0;\n    v-&gt;capacity = 0;\n}\n\nint dynArraySize(struct dynArr *v) {\n    return v-&gt;size;\n}\n\nvoid _dynArraySetCapacity(struct dynArr *v, int newCapacity) {\n    assert(newCapacity &gt; 0);\n\n    printf(\"âš™ï¸ Resizing array: old capacity = %d, new capacity = %d\\n\",\n           v-&gt;capacity, newCapacity);\n\n    if (newCapacity &lt; v-&gt;size) {\n        v-&gt;size = newCapacity; /* æˆªæ–­å·²æœ‰å…ƒç´ ï¼Œé˜²æ­¢è¶Šç•Œ */\n    }\n    TYPE *newData = (TYPE *) malloc(sizeof(TYPE) * newCapacity);\n    assert(newData != 0);\n\n    for (int i = 0; i &lt; v-&gt;size; ++i) {\n        newData[i] = v-&gt;data[i];\n    }\n\n    free(v-&gt;data);\n    v-&gt;data = newData;\n    v-&gt;capacity = newCapacity;\n}\n\nvoid dynArrayAdd(struct dynArr *v, TYPE val) {\n    /* Check if a resize is necessary */\n    if(v-&gt;size &gt;= v-&gt;capacity)\n        _dynArraySetCapacity(v, 2 * v-&gt;capacity);\n    v-&gt;data[v-&gt;size] = val;\n    v-&gt;size++;\n}\n\n/* ---------- æ¼”ç¤ºç”¨ main å‡½æ•° ---------- */\nint main() {\n    struct dynArr arr;\n    dynArrayInit(&arr, 2);  // åˆå§‹å®¹é‡è®¾ä¸º 2\n    printf(\"Initial capacity: %d\\n\", arr.capacity);\n\n    // è¿ç»­æ’å…¥å¤šä¸ªå…ƒç´ ï¼Œè§¦å‘æ‰©å®¹\n    for (int i = 0; i &lt; 10; i++) {\n        dynArrayAdd(&arr, i * 1.1);  // æ’å…¥ i*1.1\n        printf(\"Added %.1f | size = %d, capacity = %d\\n\",\n               arr.data[arr.size-1], arr.size, arr.capacity);\n    }\n\n    // æ‰“å°æ•°ç»„å†…å®¹\n    printf(\"Final array: [\");\n    for (int i = 0; i &lt; arr.size; i++) {\n        printf(\"%.1f\", arr.data[i]);\n        if (i &lt; arr.size-1) printf(\", \");\n    }\n    printf(\"]\\n\");\n\n    dynArrayFree(&arr);\n    return 0;\n}"
  },
  {
    "objectID": "c-programming/DynamicArray1.html#output",
    "href": "c-programming/DynamicArray1.html#output",
    "title": "Dynamic Array WS14",
    "section": "Output",
    "text": "Output\nInitial capacity: 2\nAdded 0.0 | size = 1, capacity = 2\nAdded 1.1 | size = 2, capacity = 2\nâš™ï¸ Resizing array: old capacity = 2, new capacity = 4\nAdded 2.2 | size = 3, capacity = 4\nAdded 3.3 | size = 4, capacity = 4\nâš™ï¸ Resizing array: old capacity = 4, new capacity = 8\nAdded 4.4 | size = 5, capacity = 8\nAdded 5.5 | size = 6, capacity = 8\nAdded 6.6 | size = 7, capacity = 8\nAdded 7.7 | size = 8, capacity = 8\nâš™ï¸ Resizing array: old capacity = 8, new capacity = 16\nAdded 8.8 | size = 9, capacity = 16\nAdded 9.9 | size = 10, capacity = 16\nFinal array: [0.0, 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9]\n=== Code Execution Successful ==="
  },
  {
    "objectID": "c-programming/DynamicArray1.html#note",
    "href": "c-programming/DynamicArray1.html#note",
    "title": "Dynamic Array WS14",
    "section": "Note",
    "text": "Note\nIn C, the compiler cannot identify whether the result would exceed maximum memory location of the array. Thus we need the dynamic array"
  },
  {
    "objectID": "c-programming/index.html",
    "href": "c-programming/index.html",
    "title": "C è¯­è¨€ç¼–ç¨‹åšå®¢",
    "section": "",
    "text": "æ¬¢è¿æ¥åˆ° C è¯­è¨€ç¼–ç¨‹ä¸“åŒºï¼è¿™é‡Œåˆ†äº«ç³»ç»Ÿç¼–ç¨‹ã€ç®—æ³•å®ç°ç›¸å…³å†…å®¹ã€‚\n\n\n\n\n\n\n\n\n\nUntitled\n\n\n\n\n\n\n\n\n2025-11-02\n\n\n\n\n\n\n\nSolutions 5.3 Optimized Strcat.C\n\n\n\n\n\n\n\n\n2025-11-02\n\n\n\n\n\n\n\nPointer\n\n\n\n\n\n\n\n\n2025-11-02\n\n\n\n\n\n\n\nHackerRank C Solutions\n\n\n\n\n\n\n\n\n2025-11-02\n\n\n\n\n\n\n\nLinked list Program\n\n\n\n\n\n\n\n\n2025-11-02\n\n\n\n\n\n\n\nDynamic Array WS14\n\n\n\n\n\n\n\n\n2025-11-02\n\n\n\n\n\n\n\nHackerRank C Solutions\n\n\n\n\n\n\n\n\n2025-10-11\n\n\n\n\n\n\n\npushback complete program integer version\n\n\n\n\n\n\n\n\n2025-09-27\n\n\n\n\n\n\n\nLinkedlist Attempt,recitating push_back function , print function,\n\n\n\n\n\n\n\n\n2025-09-27\n\n\n\n\n\n\n\nLinkedlist Attempt,recitating push_back function , print function,\n\n\n\n\n\n\n\n\n2025-09-26\n\n\n\n\n\n\n\nSolutions 5.3 Optimized Strcat.C\n\n\næ–‡ç« æè¿°\n\n\n\n\n\n2024-01-15\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "c-programming/October5thPractice.html",
    "href": "c-programming/October5thPractice.html",
    "title": "HackerRank C Solutions",
    "section": "",
    "text": "#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct Node{\n int data;\n struct Node *next;\n}\n\nint main(void);\nvoid print_list(Node *head);\n\nNode* push_back(Node *last, int value);\n\nNode* push_back(Node *last, int value){\n    if(last == NULL){\n        last = (Node *)malloc(sizeof(Node));\n        last-&gt;data = value;\n        last-&gt;next = NULL;\n        return last;\n    }\n    Node *newNode = (Node *)malloc(sizeof(Node));\n    newNode-&gt;data = value;\n    newNode-&gt;next = last;\n    return newNode;\n}\nvoid print_list(Node *head){\n    for(Node *cur = head;cur;cur = cur-&gt;next){\n        printf(\"%d\",cur-&gt;data);\n        printf(\"\\n\");\n    }\n     \n    printf(\"\\n\");\n    \n}\n\n\n\n\nint main(void){\n    Node *head = NULL;\n    Node *tail = NULL;\n    head = push_back(NULL, 11111);\n    tail = head;\n    tail = push_back(tail,11112);\n    tail = push_back(tail,11113);\n    print_list(head);\n    return 0;\n}\nä½ çš„ push_back å®é™…ä¸Šåœ¨â€œå¤´éƒ¨æ’å…¥â€ï¼ˆæ›´åƒ push_frontï¼‰ï¼Œè€Œä¸”æ²¡æœ‰æŠŠæ—§çš„ tail è¿åˆ°æ–°èŠ‚ç‚¹ä¸Šï¼Œæ‰€ä»¥ head ä»ç„¶åªæŒ‡å‘ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ 11111ï¼Œå®ƒçš„ next ä¾æ—§æ˜¯ NULLï¼Œæ‰“å°å½“ç„¶åªä¼šè¾“å‡ºä¸€ä¸ªæ•°ã€‚\nå…³é”®é”™è¯¯åœ¨è¿™é‡Œï¼š\nnewNode-&gt;next = last; // è¿™è¡ŒæŠŠæ–°èŠ‚ç‚¹æŒ‡å‘äº†æ—§ tailï¼ˆç­‰äºå¾€å‰æ’ï¼‰ return newNode; // ä½†æ²¡æœ‰è®©æ—§ tail-&gt;next æŒ‡å‘æ–°èŠ‚ç‚¹\næŠŠå®ƒæ”¹æˆçœŸæ­£çš„â€œå°¾æ’â€ï¼šè®©æ—§ lastï¼ˆä¹Ÿå°±æ˜¯å½“å‰å°¾èŠ‚ç‚¹ï¼‰çš„ next æŒ‡å‘æ–°èŠ‚ç‚¹ï¼›æ–°èŠ‚ç‚¹çš„ next ç½®ä¸º NULLï¼›ç„¶åè¿”å›æ–°å°¾èŠ‚ç‚¹å³å¯ã€‚\nå¦å¤–ä½ å°‘äº† typedef çš„åˆ«åå®šä¹‰ã€‚ä¸‹é¢æ˜¯ä¸€ä»½æœ€å°æ”¹åŠ¨ã€å¯å·¥ä½œçš„ç‰ˆæœ¬ï¼š\n#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt;\ntypedef struct Node{ int data; struct Node *next; } Node;\nvoid print_list(Node *head);\nNode* push_back(Node last, int value){ Node newNode = (Node *)malloc(sizeof(Node)); if (!newNode) { perror(â€œmallocâ€); exit(1); } newNode-&gt;data = value; newNode-&gt;next = NULL;\nif (last) {\n    last-&gt;next = newNode;   // æ—§å°¾å·´è¿åˆ°æ–°èŠ‚ç‚¹\n}\nreturn newNode;             // è¿”å›æ–°çš„å°¾èŠ‚ç‚¹\n}\nvoid print_list(Node head){ for (Node cur = head; cur; cur = cur-&gt;next){ printf(â€œ%dâ€, cur-&gt;data); } printf(â€œâ€); }\nint main(void){ Node head = NULL; Node tail = NULL;\nhead = push_back(NULL, 11111); // åˆ›å»ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹\ntail = head;                   // å¤´å°¾åŒä¸€èŠ‚ç‚¹\n\ntail = push_back(tail, 11112); // è¿½åŠ åˆ°å°¾éƒ¨ï¼Œæ›´æ–° tail\ntail = push_back(tail, 11113);\n\nprint_list(head);              // è¾“å‡º 11111 11112 11113\nreturn 0;\n}\nè¦ç‚¹å°ç»“ï¼š\nâ€œå°¾æ’â€é€»è¾‘ï¼šlast-&gt;next = newNode; newNode-&gt;next = NULL; return newNode;\nç¬¬ä¸€ä¸ªèŠ‚ç‚¹å•ç‹¬å¤„ç†ï¼šhead = push_back(NULL, value); tail = head;\nåˆ«å¿˜äº†è¡¥ä¸Š typedef â€¦ } Node;ï¼Œå¦åˆ™ Node è¿™ä¸ªç±»å‹åä¸å­˜åœ¨ã€‚"
  },
  {
    "objectID": "c-programming/pushbackattempt2.html",
    "href": "c-programming/pushbackattempt2.html",
    "title": "Linkedlist Attempt,recitating push_back function , print function,",
    "section": "",
    "text": "Show the code\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\ntypedef struct Node {\n    int value;\n    struct Node *next;\n}Node;\n\nNode* push_back(Node *last, int value);\nvoid print_list(Node *head);\n\nint main(void){\nNode *head = NULL;\nhead = push_back(NULL,11111);\nprint_list(head);\nreturn 0;\n}\n\nNode* push_back(Node *last, int value){\n    if(last==NULL){\n       last =(Node *)malloc(sizeof(last));\n       last-&gt;value = value;\n       last-&gt;next = NULL;\n    }\n}\n\nvoid print_list(Node *head){\n    for (Node *cur = head ; cur ; cur = cur-&gt;next)   // âŒ è¿™é‡Œæ²¡æœ‰è®© cur å‰è¿›\n        printf(\"%d\", cur-&gt;value);\n    printf(\"NULL\\n\");\n}"
  },
  {
    "objectID": "c-programming/pushbackattempt2.html#attempt-1",
    "href": "c-programming/pushbackattempt2.html#attempt-1",
    "title": "Linkedlist Attempt,recitating push_back function , print function,",
    "section": "",
    "text": "Show the code\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\ntypedef struct Node {\n    int value;\n    struct Node *next;\n}Node;\n\nNode* push_back(Node *last, int value);\nvoid print_list(Node *head);\n\nint main(void){\nNode *head = NULL;\nhead = push_back(NULL,11111);\nprint_list(head);\nreturn 0;\n}\n\nNode* push_back(Node *last, int value){\n    if(last==NULL){\n       last =(Node *)malloc(sizeof(last));\n       last-&gt;value = value;\n       last-&gt;next = NULL;\n    }\n}\n\nvoid print_list(Node *head){\n    for (Node *cur = head ; cur ; cur = cur-&gt;next)   // âŒ è¿™é‡Œæ²¡æœ‰è®© cur å‰è¿›\n        printf(\"%d\", cur-&gt;value);\n    printf(\"NULL\\n\");\n}"
  },
  {
    "objectID": "c-programming/pushbackattempt2.html#execution-result",
    "href": "c-programming/pushbackattempt2.html#execution-result",
    "title": "Linkedlist Attempt,recitating push_back function , print function,",
    "section": "execution result",
    "text": "execution result\n11111NULL"
  },
  {
    "objectID": "c-programming/setCapacityFucntionIllustration.html",
    "href": "c-programming/setCapacityFucntionIllustration.html",
    "title": "Untitled",
    "section": "",
    "text": "void _dynArraySetCapacity(struct dynArr *v, int newCapacity){\n          //when the dynamic array doesnt have enough capacity, we need to give the \n          /*a new capacity, the capacity should be double of the originla capacity of the \n           array, thus we need a paramater of the original address of the dynamic array\n          and \n          */\n          //we first need to make sure the new capacity must be greater than 0\n        assert(newCapacity &gt; 0);\n          // since this program is mainly educational, we need to print out \n        printf(\"?? Resizing array: old capacity = %d, new capacity = %d\\n\",\n           v-&gt;capacity, newCapacity);\n          // we need to consider two scenarios\n          //whether the new capacity is greater than or less than the current size\n          //if the capacity is less than the current size of the array, we cut it off\n        if(newCapacity &lt; v-&gt;size) {\n        v-&gt;size = newCapacity; //cut it off if the new capacity is less than the current size of the array\n        }\n        //Now since the new capacity is greater than the original array, we need to create a new array\n        double *newData = (TYPE *) malloc(sizeof(TYPE) * newCapacity);\n        // we need to make sure the new array which called newData which is a pointer varaiable \n        //indeed has created and it is not NULL\n        assert(newData != 0);//0 is NULL\n        \n        //Now we just copy the original array to the new array which is called newData\n        for (int i = 0; i &lt; v-&gt;size; ++i) {\n        newData[i] = v-&gt;data[i];\n        }\n        //we then destroy the original array\n        free(v-&gt;data);\n        //we now assign the value of the new array (with double the capacity of the old array\n        //to the original dynamic array \"v\"\n        v-&gt;data = newData;\n        //and we assign the new capacity value to the original array\n        v-&gt;capacity = newCapacity;\n        \n        \n        \n }"
  },
  {
    "objectID": "c-programming/setCapacityFucntionIllustration.html#key-points",
    "href": "c-programming/setCapacityFucntionIllustration.html#key-points",
    "title": "Untitled",
    "section": "key points",
    "text": "key points\nGot it ğŸ‘ â€” hereâ€™s the sequential summary of _dynArraySetCapacity:\n\n\nSequential Summary\n\nCheck input\n\nEnsure newCapacity &gt; 0 using assert.\n\nPrint info\n\nDisplay old and new capacities with printf.\n\nAdjust size if needed\n\nIf newCapacity &lt; v-&gt;size, set v-&gt;size = newCapacity to avoid overflow.\n\nAllocate new memory\n\nCreate a new array (newData) with size newCapacity.\n\nVerify allocation\n\nAssert newData is not NULL.\n\nCopy elements\n\nFor each index i up to v-&gt;size, copy v-&gt;data[i] into newData[i].\n\nFree old memory\n\nRelease the memory used by the old array with free(v-&gt;data).\n\nUpdate pointer\n\nSet v-&gt;data = newData.\n\nUpdate capacity\n\nSet v-&gt;capacity = newCapacity."
  },
  {
    "objectID": "c-programming/setCapacityFucntionIllustration.html#below-is-the-original-dynarrayadd-function",
    "href": "c-programming/setCapacityFucntionIllustration.html#below-is-the-original-dynarrayadd-function",
    "title": "Untitled",
    "section": "Below is the original dynArrayAdd function",
    "text": "Below is the original dynArrayAdd function\nwhich we need to write a setCapacity function to be compactible with it\nvoid dynArrayAdd(struct dynArr *v, TYPE val) {  \n/* Check if a resize is necessary */  \nif(v-&gt;size &gt;= v-&gt;capacity)  \n_dynArraySetCapacity(v, 2 * v-&gt;capacity);  \nv-&gt;data[v-&gt;size] = val;  \nv-&gt;size++;  \n}"
  },
  {
    "objectID": "data-structures/C++/index.html",
    "href": "data-structures/C++/index.html",
    "title": "Data Structures with C++",
    "section": "",
    "text": "æ¬¢è¿æ¥åˆ° C++ æ•°æ®ç»“æ„ä¸“åŒºï¼è¿™é‡Œåˆ†äº« STL å®¹å™¨ã€æ¨¡æ¿æŠ€å·§ä¸ç®—æ³•å®è·µã€‚\n\n\nâ† è¿”å› Data Structures é¦–é¡µ"
  },
  {
    "objectID": "data-structures/C++/index.html#æ–‡ç« ",
    "href": "data-structures/C++/index.html#æ–‡ç« ",
    "title": "Data Structures with C++",
    "section": "",
    "text": "â† è¿”å› Data Structures é¦–é¡µ"
  },
  {
    "objectID": "data-structures/Java/index.html",
    "href": "data-structures/Java/index.html",
    "title": "Data Structures with Java",
    "section": "",
    "text": "æ¬¢è¿æ¥åˆ° Java æ•°æ®ç»“æ„ä¸“åŒºï¼è¿™é‡Œæ•´ç†é›†åˆæ¡†æ¶ã€ç®—æ³•æ¨¡æ¿ä¸å®è·µç»éªŒã€‚\n\n\nâ† è¿”å› Data Structures é¦–é¡µ"
  },
  {
    "objectID": "data-structures/Java/index.html#æ–‡ç« ",
    "href": "data-structures/Java/index.html#æ–‡ç« ",
    "title": "Data Structures with Java",
    "section": "",
    "text": "â† è¿”å› Data Structures é¦–é¡µ"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome to My Blog",
    "section": "",
    "text": "This is my first Quarto website. Here I can publish notes, code, and experiments.\n\n\n\n\n\n\n\n\n\n\nC programming Modern Approach\nC solutions\nThe C answer book\nlogic circuit visualizer DigitalJS\n\n\n\n\n\nBuilt with Quarto\nPublished on Quarto Pub\n\nSource code available on GitHub\n\n\n\n\n\nğŸŒ GitHub: @TONGSUOregonState"
  },
  {
    "objectID": "index.html#åšå®¢åˆ†ç±»",
    "href": "index.html#åšå®¢åˆ†ç±»",
    "title": "Welcome to My Blog",
    "section": "",
    "text": "C programming Modern Approach\nC solutions\nThe C answer book\nlogic circuit visualizer DigitalJS\n\n\n\n\n\nBuilt with Quarto\nPublished on Quarto Pub\n\nSource code available on GitHub\n\n\n\n\n\nğŸŒ GitHub: @TONGSUOregonState"
  },
  {
    "objectID": "index.html#about-this-site",
    "href": "index.html#about-this-site",
    "title": "Welcome to My Blog",
    "section": "",
    "text": "Built with Quarto\nPublished on Quarto Pub\n\nSource code available on GitHub"
  },
  {
    "objectID": "index.html#è”ç³»æ–¹å¼-contact",
    "href": "index.html#è”ç³»æ–¹å¼-contact",
    "title": "Welcome to My Blog",
    "section": "",
    "text": "ğŸŒ GitHub: @TONGSUOregonState"
  },
  {
    "objectID": "matlab/index.html",
    "href": "matlab/index.html",
    "title": "MATLAB Blog",
    "section": "",
    "text": "æ¬¢è¿æ¥åˆ°MATLABä¸“åŒºï¼è¿™é‡Œè®°å½•æˆ‘çš„MATLABå­¦ä¹ ç¬”è®°å’Œé¡¹ç›®ç»éªŒã€‚\n\n\n\n\næˆ‘çš„MATLABé¡¹ç›®å®ç°å’Œä»£ç åˆ†æã€‚\nâ† è¿”å›ä¸»é¡µ"
  },
  {
    "objectID": "matlab/index.html#æ–‡ç« ",
    "href": "matlab/index.html#æ–‡ç« ",
    "title": "MATLAB Blog",
    "section": "",
    "text": "æˆ‘çš„MATLABé¡¹ç›®å®ç°å’Œä»£ç åˆ†æã€‚\nâ† è¿”å›ä¸»é¡µ"
  },
  {
    "objectID": "myblog/Linkedlist.html",
    "href": "myblog/Linkedlist.html",
    "title": "Linked List Demo",
    "section": "",
    "text": "```{.c} #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;\n// â€¦ è¿™é‡Œç²˜è´´å®Œæ•´çš„ Linkedlist.c ä»£ç  â€¦ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;\ntypedef struct Node { char name[32]; struct Node *next; } Node;\n/* åœ¨é“¾è¡¨å°¾éƒ¨æ’å…¥ nameï¼Œè¿”å›â€œæ–°çš„å°¾ç»“ç‚¹â€ / Node push_back(Node last, const char name) { Node p = (Node)malloc(sizeof(Node)); if (!p) { perror(â€œmallocâ€); exit(1); }\nstrncpy(p-&gt;name, name, sizeof(p-&gt;name)-1);\np-&gt;name[sizeof(p-&gt;name)-1] = '\\0';\np-&gt;next = NULL;\n\nif (last) {               // ä¸æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼šæŠŠå®ƒæ¥åœ¨å°¾å·´å\n    last-&gt;next = p;\n}\nreturn p;                 // è¿”å›æ–°çš„â€œå°¾ç»“ç‚¹â€\n}\n/* æ‰“å°é“¾è¡¨ / void print_list(Node head) { for (Node *cur = head; cur; cur = cur-&gt;next) { printf(â€œ%s%sâ€, cur-&gt;name, cur-&gt;next ? â€ -&gt; â€ : â€ -&gt; nullâ€œ); } }\n/* ç»Ÿè®¡èŠ‚ç‚¹æ•° / int count(Node h) { int numberofnodes = 0; for (Node *p = h; p != NULL; p = p-&gt;next) { numberofnodes++; } return numberofnodes; }\nint main(void) { Node head = NULL; Node tail = NULL;\n// æ„é€ å›¾é‡Œçš„åˆå§‹é“¾è¡¨ï¼šJacob -&gt; Joseph -&gt; Mary\ntail = push_back(NULL, \"Jacob\");  // ç¬¬ä¸€ä¸ªèŠ‚ç‚¹\nhead = tail;                      // è®°å½•å¤´æŒ‡é’ˆ\ntail = push_back(tail, \"Joseph\"); // æ¥åœ¨å°¾éƒ¨\ntail = push_back(tail, \"Mary\");\n\nprint_list(head);\nprintf(\"This linked list has %d nodes.\\n\\n\", count(head));\n\n// åœ¨æœ«å°¾æ’å…¥ Annï¼ˆå¯¹åº” Fig. 3.6 ç¬¬äºŒè¡Œï¼‰\ntail = push_back(tail, \"Ann\");\n\nprint_list(head);\nprintf(\"This linked list has %d nodes.\\n\", count(head));\n\nreturn 0;\n}"
  },
  {
    "objectID": "myblog/Linkedlist.html#åŸå§‹-c-ç¨‹åº",
    "href": "myblog/Linkedlist.html#åŸå§‹-c-ç¨‹åº",
    "title": "Linked List Demo",
    "section": "",
    "text": "```{.c} #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;\n// â€¦ è¿™é‡Œç²˜è´´å®Œæ•´çš„ Linkedlist.c ä»£ç  â€¦ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt;\ntypedef struct Node { char name[32]; struct Node *next; } Node;\n/* åœ¨é“¾è¡¨å°¾éƒ¨æ’å…¥ nameï¼Œè¿”å›â€œæ–°çš„å°¾ç»“ç‚¹â€ / Node push_back(Node last, const char name) { Node p = (Node)malloc(sizeof(Node)); if (!p) { perror(â€œmallocâ€); exit(1); }\nstrncpy(p-&gt;name, name, sizeof(p-&gt;name)-1);\np-&gt;name[sizeof(p-&gt;name)-1] = '\\0';\np-&gt;next = NULL;\n\nif (last) {               // ä¸æ˜¯ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ï¼šæŠŠå®ƒæ¥åœ¨å°¾å·´å\n    last-&gt;next = p;\n}\nreturn p;                 // è¿”å›æ–°çš„â€œå°¾ç»“ç‚¹â€\n}\n/* æ‰“å°é“¾è¡¨ / void print_list(Node head) { for (Node *cur = head; cur; cur = cur-&gt;next) { printf(â€œ%s%sâ€, cur-&gt;name, cur-&gt;next ? â€ -&gt; â€ : â€ -&gt; nullâ€œ); } }\n/* ç»Ÿè®¡èŠ‚ç‚¹æ•° / int count(Node h) { int numberofnodes = 0; for (Node *p = h; p != NULL; p = p-&gt;next) { numberofnodes++; } return numberofnodes; }\nint main(void) { Node head = NULL; Node tail = NULL;\n// æ„é€ å›¾é‡Œçš„åˆå§‹é“¾è¡¨ï¼šJacob -&gt; Joseph -&gt; Mary\ntail = push_back(NULL, \"Jacob\");  // ç¬¬ä¸€ä¸ªèŠ‚ç‚¹\nhead = tail;                      // è®°å½•å¤´æŒ‡é’ˆ\ntail = push_back(tail, \"Joseph\"); // æ¥åœ¨å°¾éƒ¨\ntail = push_back(tail, \"Mary\");\n\nprint_list(head);\nprintf(\"This linked list has %d nodes.\\n\\n\", count(head));\n\n// åœ¨æœ«å°¾æ’å…¥ Annï¼ˆå¯¹åº” Fig. 3.6 ç¬¬äºŒè¡Œï¼‰\ntail = push_back(tail, \"Ann\");\n\nprint_list(head);\nprintf(\"This linked list has %d nodes.\\n\", count(head));\n\nreturn 0;\n}"
  }
]